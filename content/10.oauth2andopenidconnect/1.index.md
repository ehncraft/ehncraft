---
title: RFC 6749 - OAuth 2.0 Authorization Framework
description: 'RFC 6749 outlines the core roles, token types, grant flows
  (Authorization Code, Implicit, Resource Owner Password, Client Credentials),
  security considerations, and extensibility mechanisms used widely across modern
  identity and access management systems.'
---

::tip
---
target: _blank
to: https://datatracker.ietf.org/doc/html/rfc6749
---
Read the official RFC 6749 specification at IETF
::


### What OAuth 2.0 Solves

Before OAuth 2.0, third-party applications required users to share their credentials (username and password) directly. This created several critical security issues: credentials had to be stored in clear text, servers needed to support password authentication despite security weaknesses, applications gained overly broad access, and compromise of any application meant compromise of the user's password and all protected data.

OAuth addresses these issues by introducing an authorization layer that separates the role of the client from the resource owner, issuing access tokens instead of using the resource owner's credentials.

## Core Concepts

### The Four Roles

OAuth 2.0 defines four distinct roles in the authorization process:

**Resource Owner**: An entity capable of granting access to a protected resource. When the resource owner is a person, they are referred to as an end-user.

**Resource Server**: The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.

**Client**: An application making protected resource requests on behalf of the resource owner and with its authorization. The term "client" does not imply any particular implementation characteristics.

**Authorization Server**: The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.

### Protocol Flow

The abstract OAuth 2.0 flow involves six steps where the client requests authorization from the resource owner, receives an authorization grant, exchanges it for an access token from the authorization server, and then uses that token to access protected resources on the resource server.

```
+--------+                               +---------------+
|        |--(A)- Authorization Request ->|   Resource    |
|        |                               |     Owner     |
|        |<-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant -->| Authorization |
| Client |                               |     Server    |
|        |<-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------>|    Resource   |
|        |                               |     Server    |
|        |<-(F)--- Protected Resource ---|               |
+--------+                               +---------------+
```

### Access Tokens and Refresh Tokens

**Access Token**: A string representing an authorization issued to the client, denoting a specific scope, lifetime, and other access attributes. Access tokens are used to access protected resources.

**Refresh Token**: Credentials used to obtain access tokens, intended for use only with authorization servers and never sent to resource servers. Refresh tokens enable clients to obtain new access tokens without requiring the resource owner to re-authenticate.

## Grant Types

OAuth 2.0 defines four primary authorization grant types, each suited for different use cases.


#### 1. Authorization Code Grant: Both Confidential AND Public Clients
The authorization code grant type is used to obtain both access tokens and refresh tokens 
The authorization code grant can actually be used by both client types:

**Confidential Clients**
- Examples: Traditional web applications with server-side backends
- Authentication: Can securely authenticate at the token endpoint using client secrets
- Security: The client secret provides an additional layer of security when exchanging the authorization code for tokens

**Public Clients**
- Examples: Single-page applications (SPAs), native mobile apps, desktop applications
- Authentication: Cannot securely store client secrets
- Security: Must use PKCE (Proof Key for Code Exchange) as specified in RFC 7636 to prevent authorization code interception attacks

::note

The OAuth 2.0 Security Best Current Practice (RFC 9700) now requires that:
- All clients (confidential AND public) should use the authorization code grant
- Public clients MUST use PKCE with the authorization code grant
- The implicit grant is deprecated and should not be used
::

**Flow Steps**:

1. The client directs the resource owner's user-agent to the authorization endpoint
2. The authorization server authenticates the resource owner and obtains authorization
3. The authorization server redirects back to the client with an authorization code
4. The client exchanges the authorization code for an access token at the token endpoint

**Use Cases**: Web applications with a server-side component, mobile applications with backend servers.

**Security Benefits**: The authorization code provides important security benefits, including the ability to authenticate the client and transmit the access token directly to the client without passing it through the resource owner's user-agent.

::tip
Modern implementations should use PKCE (Proof Key for Code Exchange) with the authorization code grant for enhanced security.
::

### 2. Implicit Grant

The implicit grant type is optimized for public clients known to operate a particular redirection URI, typically browser-based applications using JavaScript. Unlike the authorization code grant, the client receives the access token directly as the result of the authorization request.

**Flow Steps**:

1. The client initiates the flow by directing the user-agent to the authorization endpoint
2. The authorization server authenticates the resource owner
3. The authorization server redirects the user-agent back to the client with the access token in the URI fragment

**Limitations**: Does not support refresh tokens, does not include client authentication, and may expose the access token to the resource owner and other applications on the same device.

::warning
The implicit grant is now considered legacy. Modern browser-based applications should use the authorization code grant with PKCE instead.
::

### 3. Resource Owner Password Credentials Grant

This grant type is suitable where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged application.

**Flow Steps**:

1. The resource owner provides credentials (username and password) directly to the client
2. The client requests an access token from the authorization server's token endpoint using these credentials

**Use Cases**: First-party applications, migration from legacy authentication systems.

::warning
The authorization server should take special care when enabling this grant type and only allow it when other flows are not viable.
::

### 4. Client Credentials Grant

The client can request an access token using only its client credentials when requesting access to protected resources under its control or previously arranged with the authorization server. This grant type must only be used by confidential clients.

**Flow Steps**:

1. The client authenticates with the authorization server using its client credentials
2. The authorization server issues an access token

**Use Cases**: Service-to-service authentication, background jobs, machine-to-machine communication.

## Endpoints

### Authorization Endpoint

The authorization endpoint is used by the authorization code and implicit grant type flows. The authorization server must support the HTTP GET method for the authorization endpoint and may support the POST method as well.

**Response Types**:
- `code` - for requesting an authorization code (authorization code grant)
- `token` - for requesting an access token (implicit grant)

**Required Parameters** vary by grant type but typically include:
- `response_type`
- `client_id`
- `redirect_uri` (optional but recommended)
- `scope` (optional)
- `state` (recommended for CSRF protection)

### Token Endpoint

The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token.

**Grant Types** supported:
- `authorization_code`
- `password`
- `client_credentials`
- `refresh_token`

**Client Authentication**: A client may use the client_id request parameter to identify itself when sending requests to the token endpoint.

### Redirection Endpoint

After completing its interaction with the resource owner, the authorization server directs the resource owner's user-agent back to the client via the redirection endpoint.

**Requirements**:
- Must be an absolute URI
- Must not include a fragment component
- May include query parameters

## Scope

The authorization and token endpoints allow the client to specify the scope of the access request using the scope request parameter. The scope parameter is expressed as a list of space-delimited, case-sensitive strings.

The authorization server uses the scope to:
- Limit the access granted to the client
- Inform the client of the actual scope of the access token issued
- Potentially display to the resource owner during the authorization process

## Security Considerations

### Transport Layer Security (TLS)

The redirection endpoint should require the use of TLS when the requested response type is "code" or "token", or when the redirection request will result in the transmission of sensitive credentials over an open network.

### Endpoint Security

Lack of transport-layer security can have a severe impact on the security of the client and the protected resources it is authorized to access.

### CSRF Protection

Clients must prevent Cross-Site Request Forgery attacks on the redirection endpoint. Clients that have ensured authorization server support for PKCE may rely on the CSRF protection provided by PKCE. Otherwise, one-time use CSRF tokens carried in the state parameter must be used.

### Redirect URI Validation

When comparing client redirection URIs against pre-registered URIs, authorization servers must utilize exact string matching except for port numbers in localhost redirection URIs of native apps.

### Open Redirectors

Clients and authorization servers must not expose URLs that forward the user's browser to arbitrary URIs obtained from a query parameter, as open redirectors can enable exfiltration of authorization codes and access tokens.

## Token Refresh Flow

When an access token expires, clients can obtain a new access token using a refresh token without requiring the resource owner to re-authenticate.

**Refresh Flow**:

```
+--------+                               +---------------+
|        |--(A)------- Authorization ---->|               |
|        |             Grant               |               |
|        |                                 |               |
|        |<-(B)------- Access Token -------|               |
|        |          & Refresh Token        | Authorization |
|        |                                 |    Server     |
|        |                                 |               |
|        |--(C)------- Access Token ------>|               |
|        |                                 |               |
|        |<-(D)--- Invalid Token Error ----|               |
|        |                                 |               |
|        |--(E)------- Refresh Token ----->|               |
|        |                                 |               |
|        |<-(F)------- Access Token -------|               |
+--------+          & Optional             +---------------+
                    Refresh Token
```

## Client Types

OAuth 2.0 defines two client types based on their ability to maintain the confidentiality of their credentials:

**Confidential Clients**: Clients capable of maintaining the confidentiality of their credentials (e.g., server-side web applications).

**Public Clients**: Clients incapable of maintaining credential confidentiality (e.g., browser-based applications, native mobile apps).

## Client Registration

Before using OAuth 2.0, clients must register with the authorization server. Registration typically involves:

- Specifying the client type
- Providing redirection URIs
- Including any other information required by the authorization server

The authorization server issues the client:
- A client identifier (client_id)
- Optionally, a client secret (for confidential clients)

## Extensibility

OAuth 2.0 provides a rich authorization framework with well-defined security properties, though as a highly extensible framework with many optional components, it can produce a wide range of non-interoperable implementations.

The framework allows for:
- Defining additional grant types
- Extending response types
- Adding additional parameters to requests and responses
- Defining additional token types

## Best Practices

Based on the specification and security considerations:

1. **Always use TLS**: Protect all communication between clients, authorization servers, and resource servers
2. **Implement PKCE**: Add Proof Key for Code Exchange to authorization code flows
3. **Validate redirect URIs strictly**: Use exact string matching for redirect URI validation
4. **Use appropriate grant types**: Choose the grant type that best fits your use case and security requirements
5. **Implement state parameter**: Use the state parameter for CSRF protection
6. **Limit token scope**: Request and grant only the minimum necessary scope
7. **Rotate refresh tokens**: Consider rotating refresh tokens when issuing new access tokens
8. **Implement token expiration**: Use short-lived access tokens with refresh tokens for long-term access

## Related Specifications

- **RFC 6750**: The OAuth 2.0 Bearer Token Usage
- **RFC 6819**: OAuth 2.0 Threat Model and Security Considerations
- **RFC 7636**: Proof Key for Code Exchange (PKCE)
- **RFC 8252**: OAuth 2.0 for Native Apps
- **RFC 9700**: OAuth 2.0 Security Best Current Practice (BCP)

## Common Use Cases

### Single Sign-On (SSO)

OAuth 2.0, often combined with OpenID Connect, enables users to authenticate once and access multiple applications.

### API Authorization

Third-party applications can access user data from APIs without requiring user credentials, with granular control through scopes.

### Mobile Applications

Native mobile applications can securely authenticate users and obtain access tokens using authorization code flow with PKCE.

### Service-to-Service Authentication

Backend services can authenticate with each other using the client credentials grant.

## Interoperability Considerations

OAuth 2.0 leaves some required components partially or fully undefined, such as client registration, authorization server capabilities, and endpoint discovery. Without these components, clients must be manually and specifically configured against a particular authorization server and resource server.

To improve interoperability, consider implementing:
- RFC 8414 (Authorization Server Metadata) for endpoint discovery
- RFC 7591 (Dynamic Client Registration) for automated client registration
- Standardized scope values for common use cases


## Conclusion

RFC 6749 defines a comprehensive authorization framework that has become the industry standard for delegated authorization. While the specification provides flexibility and extensibility, implementers must carefully consider security implications and follow best practices to ensure secure deployments. Modern implementations should also incorporate updates from related specifications such as the OAuth 2.0 Security Best Current Practice (RFC 9700) and PKCE (RFC 7636).

::tip
For production implementations, always consult the latest security best practices and consider using established OAuth 2.0 libraries rather than implementing the protocol from scratch.
::

## Additional Resources

- [OAuth 2.0 Official Website](https://oauth.net/2/)
- [RFC 6749 Full Text](https://datatracker.ietf.org/doc/html/rfc6749)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/rfc9700)
- [OpenID Connect (built on OAuth 2.0)](https://openid.net/connect/)

::tip
---
target: _blank
to: https://datatracker.ietf.org/doc/html/rfc6749
---
Read the official RFC 6749 specification at IETF
::


### What OAuth 2.0 Solves

Before OAuth 2.0, third-party applications required users to share their credentials (username and password) directly. This created several critical security issues: credentials had to be stored in clear text, servers needed to support password authentication despite security weaknesses, applications gained overly broad access, and compromise of any application meant compromise of the user's password and all protected data.

OAuth addresses these issues by introducing an authorization layer that separates the role of the client from the resource owner, issuing access tokens instead of using the resource owner's credentials.

## Core Concepts

### The Four Roles

OAuth 2.0 defines four distinct roles in the authorization process:

**Resource Owner**: An entity capable of granting access to a protected resource. When the resource owner is a person, they are referred to as an end-user.

**Resource Server**: The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.

**Client**: An application making protected resource requests on behalf of the resource owner and with its authorization. The term "client" does not imply any particular implementation characteristics.

**Authorization Server**: The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.

### Protocol Flow

The abstract OAuth 2.0 flow involves six steps where the client requests authorization from the resource owner, receives an authorization grant, exchanges it for an access token from the authorization server, and then uses that token to access protected resources on the resource server.

```
+--------+                               +---------------+
|        |--(A)- Authorization Request ->|   Resource    |
|        |                               |     Owner     |
|        |<-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant -->| Authorization |
| Client |                               |     Server    |
|        |<-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------>|    Resource   |
|        |                               |     Server    |
|        |<-(F)--- Protected Resource ---|               |
+--------+                               +---------------+
```

### Access Tokens and Refresh Tokens

**Access Token**: A string representing an authorization issued to the client, denoting a specific scope, lifetime, and other access attributes. Access tokens are used to access protected resources.

**Refresh Token**: Credentials used to obtain access tokens, intended for use only with authorization servers and never sent to resource servers. Refresh tokens enable clients to obtain new access tokens without requiring the resource owner to re-authenticate.

## Grant Types

OAuth 2.0 defines four primary authorization grant types, each suited for different use cases.


#### 1. Authorization Code Grant: Both Confidential AND Public Clients
The authorization code grant type is used to obtain both access tokens and refresh tokens 
The authorization code grant can actually be used by both client types:

**Confidential Clients**
- Examples: Traditional web applications with server-side backends
- Authentication: Can securely authenticate at the token endpoint using client secrets
- Security: The client secret provides an additional layer of security when exchanging the authorization code for tokens

**Public Clients**
- Examples: Single-page applications (SPAs), native mobile apps, desktop applications
- Authentication: Cannot securely store client secrets
- Security: Must use PKCE (Proof Key for Code Exchange) as specified in RFC 7636 to prevent authorization code interception attacks

::note

The OAuth 2.0 Security Best Current Practice (RFC 9700) now requires that:
- All clients (confidential AND public) should use the authorization code grant
- Public clients MUST use PKCE with the authorization code grant
- The implicit grant is deprecated and should not be used
::

**Flow Steps**:

1. The client directs the resource owner's user-agent to the authorization endpoint
2. The authorization server authenticates the resource owner and obtains authorization
3. The authorization server redirects back to the client with an authorization code
4. The client exchanges the authorization code for an access token at the token endpoint

**Use Cases**: Web applications with a server-side component, mobile applications with backend servers.

**Security Benefits**: The authorization code provides important security benefits, including the ability to authenticate the client and transmit the access token directly to the client without passing it through the resource owner's user-agent.

::tip
Modern implementations should use PKCE (Proof Key for Code Exchange) with the authorization code grant for enhanced security.
::

### 2. Implicit Grant

The implicit grant type is optimized for public clients known to operate a particular redirection URI, typically browser-based applications using JavaScript. Unlike the authorization code grant, the client receives the access token directly as the result of the authorization request.

**Flow Steps**:

1. The client initiates the flow by directing the user-agent to the authorization endpoint
2. The authorization server authenticates the resource owner
3. The authorization server redirects the user-agent back to the client with the access token in the URI fragment

**Limitations**: Does not support refresh tokens, does not include client authentication, and may expose the access token to the resource owner and other applications on the same device.

::warning
The implicit grant is now considered legacy. Modern browser-based applications should use the authorization code grant with PKCE instead.
::

### 3. Resource Owner Password Credentials Grant

This grant type is suitable where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged application.

**Flow Steps**:

1. The resource owner provides credentials (username and password) directly to the client
2. The client requests an access token from the authorization server's token endpoint using these credentials

**Use Cases**: First-party applications, migration from legacy authentication systems.

::warning
The authorization server should take special care when enabling this grant type and only allow it when other flows are not viable.
::

### 4. Client Credentials Grant

The client can request an access token using only its client credentials when requesting access to protected resources under its control or previously arranged with the authorization server. This grant type must only be used by confidential clients.

**Flow Steps**:

1. The client authenticates with the authorization server using its client credentials
2. The authorization server issues an access token

**Use Cases**: Service-to-service authentication, background jobs, machine-to-machine communication.

## Endpoints

### Authorization Endpoint

The authorization endpoint is used by the authorization code and implicit grant type flows. The authorization server must support the HTTP GET method for the authorization endpoint and may support the POST method as well.

**Response Types**:
- `code` - for requesting an authorization code (authorization code grant)
- `token` - for requesting an access token (implicit grant)

**Required Parameters** vary by grant type but typically include:
- `response_type`
- `client_id`
- `redirect_uri` (optional but recommended)
- `scope` (optional)
- `state` (recommended for CSRF protection)

### Token Endpoint

The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token.

**Grant Types** supported:
- `authorization_code`
- `password`
- `client_credentials`
- `refresh_token`

**Client Authentication**: A client may use the client_id request parameter to identify itself when sending requests to the token endpoint.

### Redirection Endpoint

After completing its interaction with the resource owner, the authorization server directs the resource owner's user-agent back to the client via the redirection endpoint.

**Requirements**:
- Must be an absolute URI
- Must not include a fragment component
- May include query parameters

## Scope

The authorization and token endpoints allow the client to specify the scope of the access request using the scope request parameter. The scope parameter is expressed as a list of space-delimited, case-sensitive strings.

The authorization server uses the scope to:
- Limit the access granted to the client
- Inform the client of the actual scope of the access token issued
- Potentially display to the resource owner during the authorization process

## Security Considerations

### Transport Layer Security (TLS)

The redirection endpoint should require the use of TLS when the requested response type is "code" or "token", or when the redirection request will result in the transmission of sensitive credentials over an open network.

### Endpoint Security

Lack of transport-layer security can have a severe impact on the security of the client and the protected resources it is authorized to access.

### CSRF Protection

Clients must prevent Cross-Site Request Forgery attacks on the redirection endpoint. Clients that have ensured authorization server support for PKCE may rely on the CSRF protection provided by PKCE. Otherwise, one-time use CSRF tokens carried in the state parameter must be used.

### Redirect URI Validation

When comparing client redirection URIs against pre-registered URIs, authorization servers must utilize exact string matching except for port numbers in localhost redirection URIs of native apps.

### Open Redirectors

Clients and authorization servers must not expose URLs that forward the user's browser to arbitrary URIs obtained from a query parameter, as open redirectors can enable exfiltration of authorization codes and access tokens.

## Token Refresh Flow

When an access token expires, clients can obtain a new access token using a refresh token without requiring the resource owner to re-authenticate.

**Refresh Flow**:

```
+--------+                               +---------------+
|        |--(A)------- Authorization ---->|               |
|        |             Grant               |               |
|        |                                 |               |
|        |<-(B)------- Access Token -------|               |
|        |          & Refresh Token        | Authorization |
|        |                                 |    Server     |
|        |                                 |               |
|        |--(C)------- Access Token ------>|               |
|        |                                 |               |
|        |<-(D)--- Invalid Token Error ----|               |
|        |                                 |               |
|        |--(E)------- Refresh Token ----->|               |
|        |                                 |               |
|        |<-(F)------- Access Token -------|               |
+--------+          & Optional             +---------------+
                    Refresh Token
```

## Client Types

OAuth 2.0 defines two client types based on their ability to maintain the confidentiality of their credentials:

**Confidential Clients**: Clients capable of maintaining the confidentiality of their credentials (e.g., server-side web applications).

**Public Clients**: Clients incapable of maintaining credential confidentiality (e.g., browser-based applications, native mobile apps).

## Client Registration

Before using OAuth 2.0, clients must register with the authorization server. Registration typically involves:

- Specifying the client type
- Providing redirection URIs
- Including any other information required by the authorization server

The authorization server issues the client:
- A client identifier (client_id)
- Optionally, a client secret (for confidential clients)

## Extensibility

OAuth 2.0 provides a rich authorization framework with well-defined security properties, though as a highly extensible framework with many optional components, it can produce a wide range of non-interoperable implementations.

The framework allows for:
- Defining additional grant types
- Extending response types
- Adding additional parameters to requests and responses
- Defining additional token types

## Best Practices

Based on the specification and security considerations:

1. **Always use TLS**: Protect all communication between clients, authorization servers, and resource servers
2. **Implement PKCE**: Add Proof Key for Code Exchange to authorization code flows
3. **Validate redirect URIs strictly**: Use exact string matching for redirect URI validation
4. **Use appropriate grant types**: Choose the grant type that best fits your use case and security requirements
5. **Implement state parameter**: Use the state parameter for CSRF protection
6. **Limit token scope**: Request and grant only the minimum necessary scope
7. **Rotate refresh tokens**: Consider rotating refresh tokens when issuing new access tokens
8. **Implement token expiration**: Use short-lived access tokens with refresh tokens for long-term access

## Related Specifications

- **RFC 6750**: The OAuth 2.0 Bearer Token Usage
- **RFC 6819**: OAuth 2.0 Threat Model and Security Considerations
- **RFC 7636**: Proof Key for Code Exchange (PKCE)
- **RFC 8252**: OAuth 2.0 for Native Apps
- **RFC 9700**: OAuth 2.0 Security Best Current Practice (BCP)

## Common Use Cases

### Single Sign-On (SSO)

OAuth 2.0, often combined with OpenID Connect, enables users to authenticate once and access multiple applications.

### API Authorization

Third-party applications can access user data from APIs without requiring user credentials, with granular control through scopes.

### Mobile Applications

Native mobile applications can securely authenticate users and obtain access tokens using authorization code flow with PKCE.

### Service-to-Service Authentication

Backend services can authenticate with each other using the client credentials grant.

## Interoperability Considerations

OAuth 2.0 leaves some required components partially or fully undefined, such as client registration, authorization server capabilities, and endpoint discovery. Without these components, clients must be manually and specifically configured against a particular authorization server and resource server.

To improve interoperability, consider implementing:
- RFC 8414 (Authorization Server Metadata) for endpoint discovery
- RFC 7591 (Dynamic Client Registration) for automated client registration
- Standardized scope values for common use cases


## Conclusion

RFC 6749 defines a comprehensive authorization framework that has become the industry standard for delegated authorization. While the specification provides flexibility and extensibility, implementers must carefully consider security implications and follow best practices to ensure secure deployments. Modern implementations should also incorporate updates from related specifications such as the OAuth 2.0 Security Best Current Practice (RFC 9700) and PKCE (RFC 7636).

::tip
For production implementations, always consult the latest security best practices and consider using established OAuth 2.0 libraries rather than implementing the protocol from scratch.
::

## Additional Resources

- [OAuth 2.0 Official Website](https://oauth.net/2/)
- [RFC 6749 Full Text](https://datatracker.ietf.org/doc/html/rfc6749)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/rfc9700)
- [OpenID Connect (built on OAuth 2.0)](https://openid.net/connect/)